/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * ADRASHA AUTH-SERVICE API Docs
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import type {
  AddRoleDTO,
  ApiResponse,
  ErrorResponse,
  LoginRequest,
  PasswordResetRequest,
  RegistrationRequest,
  ValidationErrorResponse
} from './auth-schemas.ts';

import { customInstance } from '../client';
/**
 * Update role with given userId
 * @summary Update Role
 */
export const updateRole = (
    addRoleDTO: AddRoleDTO,
 ) => {
      
      
      return customInstance<ApiResponse>(
      {url: `/auth/updateRole`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: addRoleDTO
    },
      );
    }
  


export const getUpdateRoleMutationOptions = <TError = ValidationErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{data: AddRoleDTO}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{data: AddRoleDTO}, TContext> => {

const mutationKey = ['updateRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRole>>, {data: AddRoleDTO}> = (props) => {
          const {data} = props ?? {};

          return  updateRole(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateRole>>>
    export type UpdateRoleMutationBody = AddRoleDTO
    export type UpdateRoleMutationError = ValidationErrorResponse | ErrorResponse

    /**
 * @summary Update Role
 */
export const useUpdateRole = <TError = ValidationErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{data: AddRoleDTO}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRole>>,
        TError,
        {data: AddRoleDTO},
        TContext
      > => {

      const mutationOptions = getUpdateRoleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update Current Password with given password
 * @summary Reset Password
 */
export const resetPassword = (
    passwordResetRequest: PasswordResetRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ApiResponse>(
      {url: `/auth/resetPassword`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: passwordResetRequest, signal
    },
      );
    }
  


export const getResetPasswordMutationOptions = <TError = ValidationErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetPassword>>, TError,{data: PasswordResetRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof resetPassword>>, TError,{data: PasswordResetRequest}, TContext> => {

const mutationKey = ['resetPassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetPassword>>, {data: PasswordResetRequest}> = (props) => {
          const {data} = props ?? {};

          return  resetPassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof resetPassword>>>
    export type ResetPasswordMutationBody = PasswordResetRequest
    export type ResetPasswordMutationError = ValidationErrorResponse | ErrorResponse

    /**
 * @summary Reset Password
 */
export const useResetPassword = <TError = ValidationErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetPassword>>, TError,{data: PasswordResetRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetPassword>>,
        TError,
        {data: PasswordResetRequest},
        TContext
      > => {

      const mutationOptions = getResetPasswordMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns a user after registration
 * @summary Register New User
 */
export const registerUser = (
    registrationRequest: RegistrationRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ApiResponse>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registrationRequest, signal
    },
      );
    }
  


export const getRegisterUserMutationOptions = <TError = ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: RegistrationRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: RegistrationRequest}, TContext> => {

const mutationKey = ['registerUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerUser>>, {data: RegistrationRequest}> = (props) => {
          const {data} = props ?? {};

          return  registerUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterUserMutationResult = NonNullable<Awaited<ReturnType<typeof registerUser>>>
    export type RegisterUserMutationBody = RegistrationRequest
    export type RegisterUserMutationError = ValidationErrorResponse

    /**
 * @summary Register New User
 */
export const useRegisterUser = <TError = ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerUser>>, TError,{data: RegistrationRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerUser>>,
        TError,
        {data: RegistrationRequest},
        TContext
      > => {

      const mutationOptions = getRegisterUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns a user object after successful login
 * @summary Login for user
 */
export const loginUser = (
    loginRequest: LoginRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ApiResponse>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      );
    }
  


export const getLoginUserMutationOptions = <TError = ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['loginUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginUser>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  loginUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginUserMutationResult = NonNullable<Awaited<ReturnType<typeof loginUser>>>
    export type LoginUserMutationBody = LoginRequest
    export type LoginUserMutationError = ValidationErrorResponse

    /**
 * @summary Login for user
 */
export const useLoginUser = <TError = ValidationErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginUser>>, TError,{data: LoginRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginUser>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Admin Role required. User will not be able to login again if deleted
 * @summary delete security credintials of user
 */
export const deleteUserByAdmin = (
    id: string,
 ) => {
      
      
      return customInstance<ApiResponse>(
      {url: `/auth/users/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUserByAdminMutationOptions = <TError = ValidationErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserByAdmin>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserByAdmin>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteUserByAdmin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserByAdmin>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteUserByAdmin(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserByAdminMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserByAdmin>>>
    
    export type DeleteUserByAdminMutationError = ValidationErrorResponse | ErrorResponse

    /**
 * @summary delete security credintials of user
 */
export const useDeleteUserByAdmin = <TError = ValidationErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserByAdmin>>, TError,{id: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserByAdmin>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserByAdminMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * User will not be able to login again if deleted
 * @summary delete security credintials of current logged in user
 */
export const deleteCurrentUser = (
    
 ) => {
      
      
      return customInstance<ApiResponse>(
      {url: `/auth/users/me`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCurrentUserMutationOptions = <TError = ValidationErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurrentUser>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCurrentUser>>, TError,void, TContext> => {

const mutationKey = ['deleteCurrentUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrentUser>>, void> = () => {
          

          return  deleteCurrentUser()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCurrentUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrentUser>>>
    
    export type DeleteCurrentUserMutationError = ValidationErrorResponse | ErrorResponse

    /**
 * @summary delete security credintials of current logged in user
 */
export const useDeleteCurrentUser = <TError = ValidationErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurrentUser>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCurrentUser>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDeleteCurrentUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
